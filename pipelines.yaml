```yaml
# tech_stack_detector.py
# Pipeline for building and deploying a Java application using Maven.
# This pipeline includes stages for:
# - Building the application
# - Running unit tests
# - Performing static analysis
# - Deploying to a staging environment
# - Running integration tests against the staging environment
# - Deploying to production (manual approval required)
# This pipeline assumes that the application code is stored in a Git repository.

stages:
  - Build
  - Test
  - Static Analysis
  - Deploy to Staging
  - Integration Tests
  - Deploy to Production

variables:
  MAVEN_IMAGE: maven:3.8.6-jdk-11
  STAGING_ENVIRONMENT: staging
  PRODUCTION_ENVIRONMENT: production

build:
  stage: Build
  image: $MAVEN_IMAGE
  script:
    - echo "Building the application..."
    - mvn clean install -DskipTests # Skip tests during the build stage
  artifacts:
    paths:
      - target/*.jar # Assuming the application produces a JAR file

test:
  stage: Test
  image: $MAVEN_IMAGE
  script:
    - echo "Running unit tests..."
    - mvn test
  dependencies:
    - build # Dependent on the build stage

static_analysis:
  stage: Static Analysis
  image: $MAVEN_IMAGE
  script:
    - echo "Performing static analysis..."
    - mvn checkstyle:checkstyle # Example: Using Checkstyle for static analysis
    - mvn pmd:pmd # Example: Using PMD for static analysis
  dependencies:
    - build # Dependent on the build stage
  allow_failure: true # Allow the pipeline to continue even if static analysis fails

deploy_to_staging:
  stage: Deploy to Staging
  image: docker:latest # Using docker image for deployment
  services:
    - docker:dind
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
  script:
    - echo "Deploying to staging environment..."
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG-staging . # Build docker image
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG-staging # Push docker image
    # Add deployment commands here, e.g., using docker-compose, kubectl, etc.
    - echo "Deployment commands to staging goes here"
  environment:
    name: $STAGING_ENVIRONMENT
    url: "https://staging.example.com" # Replace with your staging URL
  dependencies:
    - build # Dependent on the build stage

integration_tests:
  stage: Integration Tests
  image: curlimages/curl # Using curl image for integration tests
  script:
    - echo "Running integration tests against staging environment..."
    # Add integration test commands here, e.g., using curl, postman, etc.
    - curl https://staging.example.com # Example test, replace with your integration test commands
  environment:
    name: $STAGING_ENVIRONMENT
    url: "https://staging.example.com" # Replace with your staging URL
  dependencies:
    - deploy_to_staging # Dependent on deploy_to_staging stage
  allow_failure: true # Allow failure for early feedback

deploy_to_production:
  stage: Deploy to Production
  image: docker:latest # Using docker image for deployment
  services:
    - docker:dind
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
  script:
    - echo "Deploying to production environment..."
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG-production . # Build docker image
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG-production # Push docker image
    # Add deployment commands here, e.g., using docker-compose, kubectl, etc.
    - echo "Deployment commands to production goes here"
  environment:
    name: $PRODUCTION_ENVIRONMENT
    url: "https://example.com" # Replace with your production URL
  dependencies:
    - integration_tests # Dependent on integration_tests stage
  when: manual # Manual approval required for deploying to production
```