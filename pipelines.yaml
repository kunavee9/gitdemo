```groovy
pipeline {
    agent {
        // Specify the agent that will execute the pipeline.  Use a label that matches your Jenkins agent setup.
        label 'nodejs'
    }
    options {
        // Prevent concurrent builds of the same pipeline
        disableConcurrentBuilds()
        // Set a build timeout (e.g., 1 hour)
        timeout(time: 1, unit: 'HOURS')
        // Abort the pipeline if a stage fails
        // Skip stages based on certain conditions - skipped in this case
        // skipStagesAfterUnstable()
        // Retry failed stages a specified number of times
        retry(3)
    }
    triggers {
        // Trigger the pipeline on changes to the main branch.  Adjust the branches as needed.
        // pollSCM('H/5 * * * *')  // Poll every 5 minutes - alternative to webhook
        githubPush(branchFilter: 'main') // Trigger on pushes to main branch
    }
    environment {
        // Define environment variables used throughout the pipeline.
        NODE_VERSION = '18.x' // Use a specific Node.js version
        NPM_CACHE_PATH = "${env.WORKSPACE}/.npm_cache"
        // Artifact Repository details (replace with your actual values)
        ARTIFACT_REPO_URL = "http://your-artifact-repo/repository/your-react-app/"
        ARTIFACT_GROUP_ID = "com.example.reactapp"
        APPLICATION_NAME = "my-react-app"

    }
    parameters {
        string(name: 'DEPLOY_ENVIRONMENT', defaultValue: 'dev', description: 'Environment to deploy to (dev, staging, prod)')
        string(name: 'IMAGE_TAG', defaultValue: 'latest', description: 'Docker image tag to deploy')
    }
    stages {
        stage('Checkout') {
            steps {
                // Checkout code from Git repository
                git branch: 'main', url: 'your-git-repository-url'
            }
        }

        stage('Dependencies') {
            steps {
                // Install Node.js based on the specified version
                nodejs(nodeJSInstallationName: 'NodeJS 18') {
                    // Configure npm cache to speed up dependency installation
                    sh "npm config set cache ${NPM_CACHE_PATH}"
                    // Install project dependencies
                    sh 'npm install'
                }
            }
        }

        stage('Lint') {
            steps {
                // Run ESLint to check for code quality issues
                nodejs(nodeJSInstallationName: 'NodeJS 18') {
                    sh 'npm run lint' // Assuming you have a lint script in package.json
                }
            }
        }

        stage('Test') {
            steps {
                // Run unit tests
                nodejs(nodeJSInstallationName: 'NodeJS 18') {
                    sh 'npm test -- --watchAll=false --coverage' // Run tests with coverage
                }
                // Publish test results (JUnit format if applicable)
                // junit 'reports/junit.xml' // Adapt path to your test report
                // Publish code coverage report
                // cobertura autoUpdateHealth: false, coberturaReportFile: 'coverage/cobertura-coverage.xml', failBuildIfNoCoverage: false, failUnhealthy: false, onlyStable: false
            }
            post {
                always {
                  // Archive test results and coverage reports for future analysis
                  archiveArtifacts artifacts: 'coverage/**', allowEmptyArchive: true
                  archiveArtifacts artifacts: 'reports/**', allowEmptyArchive: true
                }
            }
        }

        stage('Build') {
            steps {
                // Build the React application for production
                nodejs(nodeJSInstallationName: 'NodeJS 18') {
                    sh 'npm run build' // Assuming you have a build script in package.json
                }
                // Archive build artifacts
                archiveArtifacts artifacts: 'build/**', allowEmptyArchive: false
            }
        }

        stage('Docker Build & Push') {
            steps {
                // Build Docker image
                script {
                    // Get the commit SHA for tagging
                    COMMIT_SHA = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    IMAGE_NAME = "your-dockerhub-username/your-react-app:${env.IMAGE_TAG}-${COMMIT_SHA}" // Define image name
                    docker.withRegistry('https://index.docker.io/v1/', 'dockerhub-credentials') { // Replace 'dockerhub-credentials' with your Jenkins Docker Hub credentials ID
                        sh "docker build -t ${IMAGE_NAME} ."
                        sh "docker push ${IMAGE_NAME}"
                    }
                    env.DOCKER_IMAGE = IMAGE_NAME // set the docker image env variable to be used in deployments
                }
            }
        }

        stage('Push to Artifact Repository') {
            steps {
                // Publish build artifacts to a Maven-compatible artifact repository
                script {
                    // Create a unique artifact version based on build number
                    VERSION = "${env.BUILD_NUMBER}"
                    pomFile = file('pom.xml')
                    if (!pomFile.exists()) {
                        // Create a basic pom.xml if it doesn't exist
                        writeFile file: 'pom.xml', text: """
                            <?xml version="1.0" encoding="UTF-8"?>
                            <project xmlns="http://maven.apache.org/POM/4.0.0"
                                     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                                     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
                                <modelVersion>4.0.0</modelVersion>

                                <groupId>${env.ARTIFACT_GROUP_ID}</groupId>
                                <artifactId>${env.APPLICATION_NAME}</artifactId>
                                <version>${VERSION}</version>
                                <packaging>zip</packaging>  <!-- Assuming you'll package the build directory as a zip -->
                            </project>
                        """
                    }
                    // Package the build directory into a zip file
                    sh "zip -r build.zip build"
                    // Upload the zip file to the artifact repository using Maven Deploy plugin
                    // Ensure you have the 'maven-deploy' plugin installed in Jenkins
                    withCredentials([usernamePassword(credentialsId: 'artifact-repo-credentials', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) { // Replace 'artifact-repo-credentials' with your Jenkins credentials ID
                        sh "mvn deploy:deploy-file -DgroupId=${env.ARTIFACT_GROUP_ID} -DartifactId=${env.APPLICATION_NAME} -Dversion=${VERSION} -Dpackaging=zip -Dfile=build.zip -DrepositoryId=artifact-repo -Durl=${env.ARTIFACT_REPO_URL} -Dusername=\${USERNAME} -Dpassword=\${PASSWORD}"
                    }
                }
            }
        }

        stage('Deploy') {
            when {
                // Deploy only to 'dev' environment by default, unless a different environment is specified in the parameter
                expression { params.DEPLOY_ENVIRONMENT == 'dev' || params.DEPLOY_ENVIRONMENT == 'staging' || params.DEPLOY_ENVIRONMENT == 'prod' }
            }
            steps {
                script {
                   // Define deployment logic based on the target environment
                    def deployScript
                    switch (params.DEPLOY_ENVIRONMENT) {
                        case 'dev':
                            deployScript = "echo 'Deploying to Development...Docker Image:${env.DOCKER_IMAGE}'"
                            break
                        case 'staging':
                            deployScript = "echo 'Deploying to Staging...Docker Image:${env.DOCKER_IMAGE}'"
                            break
                        case 'prod':
                            deployScript = "echo 'Deploying to Production...Docker Image:${env.DOCKER_IMAGE}'"
                            break
                        default:
                            deployScript = "echo 'Invalid deployment environment specified.'"
                    }
                   sh "${deployScript}" // Execute the deployment script
                   // Example: Use kubectl to deploy to Kubernetes
                   // sh "kubectl apply -f deployment.yaml"
                }
            }
        }
    }
    post {
        // Always run these actions, regardless of build result
        always {
            // Clean the workspace to save disk space
            deleteDir()
            // Archive the console log
            archiveArtifacts artifacts: '**/pipeline.log', allowEmptyArchive: true
        }
        // Run these actions only if the build succeeds
        success {
            echo 'Build succeeded!'
            // Send a notification (e.g., email, Slack)
            // slackSend channel: '#build-notifications', color: 'good', message: "Build ${env.JOB_NAME} #${env.BUILD_NUMBER} succeeded!"
        }
        // Run these actions if the build fails
        failure {
            echo 'Build failed!'
            // Send a notification
            // slackSend channel: '#build-notifications', color: 'danger', message: "Build ${env.JOB_NAME} #${env.BUILD_NUMBER} failed!"
        }
    }
}
```