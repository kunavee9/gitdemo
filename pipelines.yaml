```yaml
# tech_stack_detector.py
# Pipeline for building, testing, and deploying a Java application using Maven.
# Follows industry best practices for CI/CD pipelines.

stages:
  - Validate
  - Build
  - Test
  - Package
  - SonarQube Analysis
  - Deploy

variables:
  MAVEN_IMAGE: maven:3.8.6-jdk-11 # Define Maven image to use. Consider using a specific tag
  MAVEN_CLI_OPTS: "-Dmaven.repo.local=.m2/repository -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn" # Define Maven CLI options for optimization

cache:
  paths:
    - .m2/repository
    - target/

validate:
  stage: Validate
  image: $MAVEN_IMAGE
  script:
    - echo "Validating pom.xml..."
    - mvn $MAVEN_CLI_OPTS validate
  tags:
    - docker # Specify a runner with Docker executor.  Adjust as needed.

build:
  stage: Build
  image: $MAVEN_IMAGE
  script:
    - echo "Building the application..."
    - mvn $MAVEN_CLI_OPTS clean compile
  tags:
    - docker

test:
  stage: Test
  image: $MAVEN_IMAGE
  script:
    - echo "Running unit tests..."
    - mvn $MAVEN_CLI_OPTS test
  tags:
    - docker
  coverage: '/Total.* ([0-9]{1,3})%/'
  artifacts:
    reports:
      junit: target/surefire-reports/TEST-*.xml

package:
  stage: Package
  image: $MAVEN_IMAGE
  script:
    - echo "Packaging the application..."
    - mvn $MAVEN_CLI_OPTS clean package -DskipTests # Skip tests during packaging, tests already ran
  tags:
    - docker
  artifacts:
    paths:
      - target/*.jar # Adjust to the actual artifact produced (e.g., .war, .ear)

sonarqube-analysis:
  stage: SonarQube Analysis
  image:
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
    GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required for proper analysis
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - echo "Running SonarQube analysis..."
    - sonar-scanner
      -Dsonar.projectKey=$SONAR_PROJECT_KEY
      -Dsonar.sources=.
      -Dsonar.host.url=$SONAR_HOST_URL
      -Dsonar.login=$SONAR_TOKEN
  allow_failure: true # Don't fail the pipeline if SonarQube analysis fails
  tags:
    - docker
  only:
    - main
    - develop

deploy:
  stage: Deploy
  image: alpine/ssh  # Using a lightweight SSH image for deployment
  before_script:
    - apk update && apk add openssh-client
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan $DEPLOY_HOST >> ~/.ssh/known_hosts
    - chmod 400 ~/.ssh/known_hosts
  script:
    - echo "Deploying the application..."
    - ssh $DEPLOY_USER@$DEPLOY_HOST "mkdir -p $DEPLOY_PATH" # Create deploy path
    - scp target/*.jar $DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH # Copy artifact to the server
    - ssh $DEPLOY_USER@$DEPLOY_HOST "$DEPLOY_SCRIPT" # Execute deploy script (e.g., restart server)
  tags:
    - docker
  environment:
    name: production
    url: $DEPLOY_URL # Define your deploy URL
  only:
    - main # Deploy only from the main branch
  when: manual # Require manual trigger for deployment

```